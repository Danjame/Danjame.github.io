<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>笔记|谢丹军的个人网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" media="screen and (max-device-width: 425px)" href="CSS/mobile/commonMobile.css"
        type="text/css">
    <link rel="stylesheet" media="not screen and (max-device-width: 425px)" href="CSS/common.css" type="text/css">
    <link rel="stylesheet" href="CSS/note.css">
    <style>
        .headNav li:nth-child(2) a {
            color: #385170;
        }
    </style>
</head>

<body>
    <div id="page">
        <div id="header">
            <div class="logo" onclick="window.location.href=('index.html')">
                <div class="logoTop">Dan</div>
                <div class="logoDown">Jun</div>
            </div>
            <div>
                <div>
                    <ul class="headNav">
                        <li><a href="index.html">
                                <div>关于</div>
                            </a></li>
                        <li><a href="note.html">
                                <div>随笔</div>
                            </a></li>
                        <li><a href="https://github.com/Danjame/MonGit" target="_blank">
                                <div>作品</div>
                            </a></li>
                    </ul>
                </div>
                <span id="menu" class="unclickMenu">
                    <em></em>
                    <span class="menuBarsOff"></span>
                    <span class="menuBarsOff"></span>
                    <span class="menuBarsOff"></span>
                    <em></em>
                </span>
            </div>
        </div>
        <div id="content">
            <div class="titleWrapper">
                <ul>
                    <li onclick="window.location.href = '#anchorHead'">
                        <div></div>
                        <div></div>
                    </li>
                    <li>
                        <div class="blank"></div>
                        <div></div>
                        <div></div>
                        <div></div>
                        <div class="blank"></div>
                    </li>
                    <li onclick="window.location.href = '#anchorFoot'">
                        <div></div>
                        <div></div>
                    </li>
                </ul>
            </div>
            <div id="artiSelection">
                <ul>
                    <li><a href="https://github.com/Danjame/Danjame.github.io/blob/master/mdNotes/JavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md"
                            target="_blank">JavaScript 高级程序设计读书笔记</a></li>
                    <li onclick="window.location.href = '#VueprojectSummary'">Vue 项目要点总结</li>
                    <li onclick="window.location.href = '#startingVue'">Vue.js 入门总结</li>
                    <li onclick="window.location.href = '#JSreview'">JavaScript 复习</li>
                    <li onclick="window.location.href = '#aboutThisSite'">关于此站</li>
                    <li onclick="window.location.href = '#marchSummary'">3月学习总结</li>
                    <li onclick="window.location.href = '#gitTutorial'">Github 使用教程</li>
                </ul>
            </div>
            <div class="textWrapper">
                <div id="anchorHead" class="anchor"></div>
                <div>
                    <h2 class="title more">更多 => <a
                            href="https://github.com/Danjame/Danjame.github.io/tree/master/mdNotes" target="_blank">新笔记
                            (Markdown格式)</a></h2>
                </div>
                <div>
                    <div id="VueprojectSummary" class="anchor"></div>
                    <h2 class="title">Vue 项目要点总结</h2>
                    <h5 class="time">2019.11.03 20:50 Leon</h5>
                    <div class="line"></div>
                    <p>该项目除了首页接口和首页数据库表格，其余都是自己挖坑填坑做出来，包括后来自己补充数据库以及增加和修改接口。该项目借助了网上免费的数据库，数据获取延时会比较大且本地服务器经常崩掉。项目 <a
                            href="https://github.com/Danjame/myProjects" target="_blank">Github</a> 地址。</p>
                    <h3>侦听属性 Watch</h3>
                    <p>如果需要Watch来侦听一个对象或者对象里某一属性的变化, 可以如下操作。</p>
                    <h4>对对象使用深度监听:</h4>
                    <p><span class="code">obj: {</span></p>
                    <p><span class="code">handler: function ( ) { do something... },</span></p>
                    <p><span class="code">deep: true</span></p>
                    <p><span class="code">} </span></p>
                    <h4>侦听对象属性:</h4>
                    <p><span class="code">'Obj.attribute': funcion ( ) { do something... }</span></p>
                    <h3>事件修饰符</h3>
                    <p>使用 <span class="code">@click.stop </span>来阻止事件冒泡。</p>
                    <p>使用 <span class="code">@click.prevent</span> 来阻止事件的默认行为。</p>
                    <h3>状态管理模式 Vuex</h3>
                    <p>我把vuex看作vue的前端数据库，在vue的任何一个组件里的数据可以放进vuex里，而其他任何组件可以直接从vuex里获取其他组件存放的数据。所有的公用数据放在vuex的state对象里，通过dispatch和commit分别调用actions和mutations的方法来存放数据，但是实际上我们可以跳过actions直接使用commit调用mutation来存放数据。
                    </p>
                    <h3>Vue Router</h3>
                    <p>个人更加偏向于使用编程式导航:</p>
                    <p>1. 其可以更好地帮助你根据不同的条件跳转到不同的地址。 </p>
                    <p>2. 在跳转之前可以先进行某些条件的判断，当条件满足再进行跳转，否则不跳转。</p>
                    <p>3. 可以在页面跳转时进行其他操作。 </p>
                </div>
                <div>
                    <div id="startingVue" class="anchor"></div>
                    <h2 class="title">Vue.js 入门总结</h2>
                    <h5 class="time">2019.10.19 23:58 Leon</h5>
                    <div class="line"></div>
                    <h3>环境搭建</h3>
                    <p>去node官网下载安装node.js, node里面已经集成了npm</p>
                    <p>终端下安装:</p>
                    <p>1. <span class="code">npm install vue</span></p>
                    <p>2. <span class="code">npm install –global vue-cli</span></p>
                    <p>3. <span class="code">vue init webpack my-project</span></p>
                    <h3>项目文件说明</h3>
                    <p>1. Static: 静态资源</p>
                    <p>2. Node_modeules: 项目依赖的第三方node包</p>
                    <p>3. Src: 整个项目的源代码</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. Main.js: 项目的入口文件</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b. App.vue: 项目的原始根组件 </p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c. Router</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Index.js: 路由文件</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d. Components: 项目组件</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e. Assets: 图片资源</p>
                    <p>4. Config: 项目的配置文件 </p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. Index.js: 基础配置信息</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b. Dev.env.js: 开发环境的配置信息</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c. Prod.env.js: 线上环境配置信息</p>
                    <p>5. Build: 项目web-pack的配置内容</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. Webpack.base.conf.js 的resolve对象可定义路径别名</p>
                    <p>6. Package.json: 项目开发的依赖</p>
                    <p>7. Package-lock.json: 第三方包的具体版本</p>
                    <p>8. LICENSE: 开源协议的说明</p>
                    <p>9. Index.html: 首页默认的模版文件</p>
                    <p>10. Gitignore: 定义不被提交到git的文件 </p>
                    <p>11. Eslintrc.js: 配置了代码的规范</p>
                    <p>12. Eslintignore: 配置了不受到Eslinktrc影响到文件</p>
                    <p>13. Editorconfig: 配置了编辑器的自动化语法</p>
                    <p>14. Balbelrc: 用于作语法的转换</p>
                    <h3>多页应用与单页应用</h3>
                    <p>多页应用：每次页面跳转都会返回一个新的HTML页面，首屏时间快，搜索引擎优化效果好，但是页面切换慢。 </p>
                    <p>单页应用：每次页面跳转都会通过JS动态把当前内容删除，然后再渲染新的DOM结构，页面跳转不需要做HTML请求，减少http发送时延，因此页面切换快，但是首屏时间慢，搜索引擎优化效果差。</p>
                    <h3>Vue.js知识要点</h3>
                    <p>1. 以vue结尾的都是单文件组件。</p>
                    <p>2. 双向绑定使用v-model。</p>
                    <p>3. 路由就是根据不同的网址，返回不同的内容。</p>
                    <p>4. Tempalte里面只能有一个根标签。</p>
                    <p>5. Ref用法：标签使用ref绑定DOM, 逻辑里使用<span class="code">this.$refs</span>操作DOM (尽量避免操作DOM)。 </p>
                    <p>6. 父子组件传递数据 </p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. 父传子：父组件页面的子组件标签上绑定父组件的data里的属性，子组件里使用props来接收该属性。 </p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b. 子传父：子组件里使用<span class="code">this.$emit('event',
                            params)</span>向外触发事件和传递数据，父组件页面的子组件标签上使用@event监听事件并且触发函数，通过函数给data里的属性赋值。</p>
                    <p>7. 父子组件数据联动: 使用watch监听传送的数据变化。 </p>
                    <p>8. Vuex: vue.js的状态管理库，它采用集中式存储管理应用的所有组件的状态，可以利用vue.js的数据响应机制来进行高效的状态更新。 </p>
                    <p>9. Router-link: 使用属性tag可以改变其默认的a标签。 </p>
                    <p>10. Keep-alive 是一个包裹组件，可以缓存不活动的组件实例，而不销毁它们。而以下两个钩子会在keep-alive树内所有的嵌套组件中触发:</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. Activated: 展示组件实例时触发</p>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b. Deactivated: 跳出组件实例时触发</p>
                    <p>11. 递归组件：在组件中引用组件自身，把驼峰式命名的组件名字使用"-"拆分作为标签名即可使用递归组件。</p>
                    <p>12. Transition是个包裹组件，只会把过渡效果应用到其包裹的内容上，不会额外渲染DOM元素，也不会出现在检测过的组件层级中。</p>
                    <h3>其他</h3>
                    <p><span class="code"></span>设定宽高比的方法:</p>
                    <p><span class="code">Width: 100%;</span></p>
                    <p><span class="code">Overflow:hidden;</span></p>
                    <p><span class="code">Height: 0;</span></p>
                    <p><span class="code">Padding-bottom: 50%;</span></p>
                    <p>多余文字显示为省略号的方法:</p>
                    <p><span class="code">Overflow:hidden;</span></p>
                    <p><span class="code">White-space: nowrap;</span></p>
                    <p><span class="code">Text-overflow: ellipsis;</span></p>
                </div>
                <div>
                    <div id="JSreview" class="anchor"></div>
                    <h2 class="title">JavaScript 复习</h2>
                    <h5 class="time">2019.10.16 01:22 Leon</h5>
                    <div class="line"></div>
                    <h3>移动端 Touch 事件</h3>
                    <p>1. Touch 屏幕触摸事件: <span class="code">touchstart</span>, <span class="code">touchmove</span>, <span
                            class="code">touchend</span></p>
                    <p>2. Touch 事件的触发会产生对象数组: <span class="code">touches</span>, <span
                            class="code">changedTouches</span>, <span class="code">targetTouches</span></p>
                    <p>3. 通过 <span class="code">event.touches[0]</span>, <span
                            class="code">event.changedTouches[0]</span>, <span
                            class="code">event.targetTouches[0]</span> 可以获取触点对象。</p>
                    <p>4. 触点对象包含的常用属性: <span class="code">screenX</span>, <span class="code">screenY</span>, <span
                            class="code">clientX</span>, <span class="code">clientY</span>, <span
                            class="code">pageX</span>, <span class="code">pageY</span>, <span class="code">target</span>
                    </p>
                    <h3>元素id直接获取 DOM </h3>
                    <p>做增删改查Demo的时候发现,
                        元素的id名直接就变成了全局变量，不需要通过方法来获取。问了别人，有人说是H5的新规范，有人说是一种BUG。如果说这是一种新规范，那么这种新规范的缺点就太明显了，因为全局变量或者对象就不能和元素id同名了，否则会造成混乱。
                    </p>
                    <h3>Apply 与 Call </h3>
                    <p>同: 两者都是用于改变this的指向，也是函数的调用方式，如果没有传入参数或者传入null，那么this的指向将会是默认的window。</p>
                    <p>异: Apply传入的函数参数是一个参数组，而Call传入的函数参数是相互独立的参数。</p>
                </div>
                <div>
                    <div id="aboutThisSite" class="anchor"></div>
                    <h2 class="title">关于此站</h2>
                    <h5 class="time">2019.06.30 23:21 Porto</h5>
                    <div class="line"></div>
                    <h3>响应式和自适应</h3>
                    <p>在网站开发过程中，我们往往需要考虑到移动端的视觉效果需要符合桌面端的视觉效果。但是和物理像素px不同的是，CSS中的像素px是个相对单位。大部分的桌面显示器的物理像素等同于CSS像素，而目前主流的手机屏幕的物理像素都远远超过了桌面显示器的物理像素，也就是说，同样的面积，移动端会使用更多的物理像素来显示CSS的像素单位。因此开发移动端的页面需要在head标签中加入
                        <span class="code">&lt;meta name="viewport" content="width=device-width,
                            initial-scale=1”&gt;</span>
                        。即让viewport宽度等同于设备宽度，同时不允许用户手动缩放。</p>
                    <p>媒体查询的使用，首先需要有一个默认样式，如果后面使用
                        <span class="code">@media</span>
                        媒体查询写入不同的CSS, 不需要改变的样式则不需写入，会自动采用默认的样式。需要注意的是，如果媒体查询的条件有重合的话，比如
                        <span class="code">min-width: 300px</span>
                        是属于
                        <span class="code">min-width: 500px</span>
                        范围之内的，所以媒体条件
                        <span class="code">min-width: 300px</span>
                        的样式需要写在
                        <span class="code">min-width: 500px</span>
                        后面，否则会后者的样式会覆盖前者的样式。</p>
                    <p>如果移动端样式和桌面端样式有较大的不一，可以通过在head标签中的link里加入媒体条件，根据屏幕宽度，自动加载独立的css文件。但是我发现尽管给移动端（使用
                        <span class="code">min-device-width</span>
                        ）加载独立的CSS文件，若后面再加入不同的媒体查询条件，比如
                        <span class="code">min-width</span>
                        的使用会与
                        <span class="code">min-device-width</span>
                        有条件上的重合，导致同时导入两个css文件，那是因为
                        <span class="code">&lt;meta name="viewport" content="width=device-width,
                            initial-scale=1”&gt;</span>
                        的使用让
                        <span class="code">min-width</span>
                        实际上等同于
                        <span class="code">min-device-width</span>
                        。为了解决这个问题，对于移动端和桌面端的CSS文件加载条件，我分别使用了
                        <span class="code">screen and (max-device-width)</span>
                        和
                        <span class="code">not screen and (max-device-width)</span>
                        。这样就不会出现同时加载两个CSS文件的情况了。</p>
                    <p>对于不同的设备，为了防止冗余的函数和变量占用内存，动画页面的JS我也是独立写了移动端和桌面端，通过页面初始化使用
                        <span class="code">matchMedia()</span>
                        方法判断当前设备宽度，自行加入在
                        <span class="code">&lt;script&gt;</span>
                        标签里加入的src路径。</p>
                    <h3>请求动画帧API</h3>
                    <p>原想使用
                        <span class="code">requestAnimationFrame</span>
                        代替
                        <span class="code">setTimeout</span>
                        以优化动画，节省资源。但是由于该请求动画帧API无法控制动画速度以及时间，最终放弃使用。但是我使用了该方法监控DOM样式的变化（以前使用
                        <span class="code">setInterval</span>
                        ）。</p>
                    <h3>HTML5的移动端触摸事件</h3>
                    <p>计算移动端的滑屏方向，可以通过监听
                        <span class="code">touchstart</span>
                        事件和
                        <span class="code">touchend</span>
                        事件分别获取
                        <span class="code">event</span>
                        对象的横纵坐标，把两者的横纵坐标进行减法计算即可判断滑屏方向。但是上下滑动难免会有轻微的左右滑动（或者左右滑动难免会有轻微的上下滑动），由此造成的判断会导致事与愿违。因此我们需要使用Math.abs()方法对比横纵坐标的计算结果，绝对值大者即为触摸滑屏方向。
                        <span class="code">event.preventDefault()</span>
                        方法可以阻止默认处理方式，比如可以监听
                        <span class="code">document</span>
                        的
                        <span class="code">touchmove</span>
                        事件，执行该方法以阻止ios safari 和 chrome的“橡皮筋效果”。</p>
                    <h3>优化和兼容</h3>
                    <p>由于每个浏览器的内核和渲染机制都有所差别，所以我在针对移动端浏览器的兼容和优化上花了不少时间，但是效果还是难以让人满意，还需多加学习。</p>
                </div>
                <div>
                    <div id="marchSummary" class="anchor"></div>
                    <h2 class="title">3月份学习总结</h2>
                    <h5 class="time">2019.03.29 05:37 Porto</h5>
                    <div class="line"></div>
                    <h3>CSS3轮播图</h3>
                    <p>CSS3动画可开启GPU硬件加速渲染动画, 因此效果更加流畅, 帧数更高, 为了实现无缝轮播, 需要:</p>
                    <p>1. 在图片组最后再放置一张首张图片, 当焦点于最后一张的时候仍然可以滑动到重复放置的第一张图, 此刻又立刻切换到实际的第一张图, 造成无缝的视觉。</p>
                    <p>2. 对于切换到第一张重点需要用到事件监听, 通过监听
                        <span class="code">transitionend</span>
                        的事件, 可以在不占用定时器的次数的前提下, 于定时器的外部进行无动画无过度地改变动画对象的变型
                        <span class="code"></span>transform
                        。 以此来实现css3的无缝轮播。</p>
                    <h3>纯JS轮播图</h3>
                    <p>动画可控性更好, 但是cpu占用大, 动画帧数低。</p>
                    <p>原理同样需要在图片组最后放置第一张图实现无缝的视觉。</p>
                    <p>难点: 关于
                        <span class="code">math.ceil()</span>
                        和
                        <span class="code">math.floor()</span>
                        两个方法的使用, 在负值的时候要取整取更小的值, 而正值的时候需要取更大的整数, 意味着取整都要让位移最大化, 最后才能走完目标距离, 否则, 永远无法到达目标距离。</p>
                    <p>尽量以
                        <span class="code">setTimeout</span>
                        和递归来代替
                        <span class="code">setInterval</span>
                        , 因为
                        <span class="code">setTimeout</span>
                        可以每次释放内存, 而
                        <span class="code">setInterval</span>
                        会一直占用资源, 直到其被清除。</p>
                    <h3>选项卡</h3>
                    <p>如果直接对每个
                        <span class="code">li</span>
                        标签进行遍历绑定事件, 会消耗内存, 影响性能. 而使用事件委托的方法, 让标签被点击之后才触发事件的绑定和回调相应的函数可以节省更多的内存。</p>
                    <p>在遍历的时候使用
                        <span class="code">let</span>
                        变量可以打印每次的i值, 而使用
                        <span class="code">var</span>
                        变量只会输出最后一个
                        <span class="code">i</span>
                        的值。</p>
                    <h3>布局</h3>
                    <p>虽然使用
                        <span class="code">table</span>
                        属性的结构布局更加简单, 上手快, 但是实际上加载速度慢, 占用更多的资源。</p>
                </div>
                <div>
                    <div id="gitTutorial" class="anchor"></div>
                    <h2 class="title">Github 使用教程</h2>
                    <h5 class="time">2019.03.29 05:26 Porto</h5>
                    <div class="line"></div>
                    <h4>自学前端半年了，今天才对github的使用有了初步了解，于是根据自己的经验总结了使用方法。</h4>
                    <p>1. 进入<a href="https://github.com/">Github</a> 的网站注册帐号。</p>
                    <p>2. 下载安装<a href="https://git-scm.com/downloads">git</a>。</p>
                    <p>3. 打开终端输入
                        <span class="code">git --version</span>
                        指令可查看已安装git的版本。</p>
                    <p>4. 查看.ssh: 在终端输入指令
                        <span>cd ~/.ssh</span>
                        。如果提示
                        <span class="code">-bash:cd: ～/.ssh: No such file or directory</span>
                        ，说明ssh不存在，则需要创建一个。在终端输入指令
                        <span class="code">ssh-keygen -t rsa -C email</span>，
                        email写注册帐号时的邮箱地址。</p>
                    <p>回车之后会出现以下提示:</p>
                    <p class="code">Generating public/private rsa key pair.</p>
                    <p class="code">Enter file in which to save the key (/Users/username/.ssh/id_rsa):（此为默认路径，可不修改）</p>
                    <p class="code">Created directory '/Users/username/.ssh'.</p>
                    <p class="code">Enter passphrase (empty for no passphrase): （设置4位以上的密码）</p>
                    <p class="code">Enter same passphrase again: （再次输入密码以确认）</p>
                    <p class="code">Your identification has been saved in /Users/username/.ssh/id_rsa</p>
                    <p>5. 回到github网站登录帐号，右上角用户头像点击选择 Settings，然后点击左边 Personal settings 一栏
                        中的 SSH and GPG keys，进入之后选择 New SSH key，然后填写Title和Key。</p>
                    <p>Title: 可填写注册邮箱地址</p>
                    <p>Key: 进入目录
                        <span class="code">/User/username/.ssh/</span>
                        找到 is_rsa.pub，用文本编辑器打开，拷贝里面的内容即可。(
                        打开Finder使用快捷键 Command + Shift + h 进入用户根目录，再使用快捷键 Command + Shift + . 取消文
                        件隐藏即可找到is_rsa.pub文件)</p>
                    <p>最后点击 Add SSH key。</p>
                    <p>6. 创建版本库，回到github个人主页，点击位于中央的 Start a project, 在 Repository name 处输入一
                        个版本库名称，点击Create repository。</p>
                    <p>7. 成功创建版本库之后，在终端使用
                        <span class="code">cd /文件夹路径</span>
                        选择你想建立本地版本库的文件夹路径，比如我的是项目是在桌面的
                        文件夹myGit,则输入
                        <span class="code">cd /Users/username/Desktop/myGit</span>
                        ，然后按照github上新库的提示
                        <span>…or create a new
                            repository on the command line</span>
                        依次输入指令，比如我的是:</p>
                    <p class="code">echo "# MonGit" >> README.md</p>
                    <p class="code">git init</p>
                    <p class="code">git add README.md</p>
                    <p class="code">git commit -m "first commit"</p>
                    <p class="code">git remote add origin https://github.com/username/myGit.git</p>
                    <p class="code">git push -u origin master</p>
                    <p>然后会出现以下提示：</p>
                    <p class="code">Username for 'https://github.com': （输入github上的用户名）</p>
                    <p class="code">Password for 'https://username@github.com': （输入github的登录密码）</p>
                    <p>8. 提交项目，打开终端，同样利用cd指令进入本地仓库，输入:</p>
                    <p class="code">git add 文件/文件夹路径</p>
                    <p class="code">git commit –m “你的注释”</p>
                    <p class="code">git push origin master</p>
                    <p>成功执行后会显示几行数据，最后以
                        <span class="code">master -> master</span>
                        结束。</p>
                </div>
                <div id="anchorFoot"></div>
            </div>
        </div>
    </div>
    <script type="text/javascript" class="commonScriptMobile"></script>
    <script type="text/javascript">
        if (window.matchMedia("(max-device-width:425px)").matches) {
            document.querySelector(".commonScriptMobile").src = "JS/mobile/commonMobile.js";
        }
    </script>
    <script type="text/javascript" src="JS/note.js"></script>
</body>

</html>